//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Final.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom_map.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/ssi.h"
#include "driverlib/adc.h"
#include "driverlib/interrupt.h"
#include "inc/tm4c123gh6pm.h"
#include "driverlib/uart.h"


int SIZE_L = 6;
int SIZE_W = 7;
#define SIZE_L    6
#define SIZE_W   7

//*****************************************************************************
volatile char newChar;
void PortFunctionInit(void)
{
		volatile uint32_t ui32Loop;
    //
    // Enable Peripheral Clocks 
    //
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC1);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);

    //
    // Enable pin PE2 for ADC AIN1
    //
    MAP_GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_2);

    //
    // Enable pin PE3 for ADC AIN0
    //
    MAP_GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);

    //
    // Enable pin PB5 for GPIOInput
    //
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTB_BASE, GPIO_PIN_5);

    //
    // Enable pin PF2 for GPIOOutput
    //
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2);

    //
    // Enable pin PF4 for GPIOInput
    //
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_4);

    //
    // Enable pin PF0 for GPIOInput
    //

    //
    //First open the lock and select the bits we want to modify in the GPIO commit register.
    //
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) = 0x1;

    //
    //Now modify the configuration of the pins that we unlocked.
    //
    MAP_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_0);

    //
    // Enable pin PF3 for GPIOOutput
    //
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);

    //
    // Enable pin PF1 for GPIOOutput
    //
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1);
		GPIO_PORTB_PUR_R |= 0x20; 
}

void UART_int_init()
{
	  SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);


    UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 115200,
        (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
		UARTFlowControlSet(UART0_BASE,UART_FLOWCONTROL_RX);
	
		IntPrioritySet(INT_UART0, 0x00);
    IntMasterEnable(); //enable processor interrupts
    IntEnable(INT_UART0); //enable the UART interrupt
    UARTIntEnable(UART0_BASE, UART_INT_RX | UART_INT_RT); //only enable RX and TX interrupts

}


void UARTIntHandler(void)
{
    uint32_t ui32Status;
    UARTIntClear(UART0_BASE, ui32Status); //clear the asserted interrupts
    ui32Status = UARTIntStatus(UART0_BASE, true); //get interrupt status
	
		while(UARTCharsAvail(UART0_BASE)) //loop while there are chars
		{
		newChar = UARTCharGet(UART0_BASE);
			
		}

}

void UARTStringPut(char arr[], int size){
	for(int i = 0; i < size; i++)
	{
		UARTCharPut(UART0_BASE, arr[i]);
	}
}


void ADC_init(void)
{
		SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0); //ADC0 enable 
		SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC1); //ADC1 enable 
		GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_2);//portE2 ADC0
		GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);//portE3 ADC1
    ADCHardwareOversampleConfigure(ADC0_BASE,64);//64 sample 
		ADCHardwareOversampleConfigure(ADC1_BASE,64);//64 sample 
    ADCSequenceDisable(ADC0_BASE,3);//Disable 
		ADCSequenceDisable(ADC1_BASE,3);//Disable 
    ADCSequenceConfigure(ADC0_BASE,3,ADC_TRIGGER_PROCESSOR,0); //ADC_TRIGGER_TIMER 
		ADCSequenceConfigure(ADC1_BASE,3,ADC_TRIGGER_PROCESSOR,0); //ADC_TRIGGER_TIMER 
    ADCSequenceStepConfigure(ADC0_BASE , 3 , 0 , ADC_CTL_CH1 | ADC_CTL_IE | ADC_CTL_END);//CH1-->PE2 ---- IE-->interrupt enable
		ADCSequenceStepConfigure(ADC1_BASE , 3 , 0 , ADC_CTL_CH0 | ADC_CTL_IE | ADC_CTL_END);//CH0-->PE3 ---- IE-->interrupt enable
    ADCSequenceEnable(ADC0_BASE,3);
		ADCSequenceEnable(ADC1_BASE,3);
}

void Gen_Board(char board[SIZE_L][SIZE_W])
{
	UARTStringPut("_________________\n\r", 19);
	for(int i = 0; i < SIZE_L; i++)
	{
		UARTStringPut("-", 1);
		for(int j = 0; j < SIZE_W; j++)
		{
			UARTCharPut(UART0_BASE, '|');
			UARTCharPut(UART0_BASE, board[i][j]);
		}
		UARTStringPut("|-\n\r", 4);
	}
	UARTStringPut("||-------------||\n\r", 19);
}
	

/*
 * moves the up arrow according to the players desire
 */
void moveCusor(int position)
{
	
			UARTCharPut(UART0_BASE, '\r');
	 
	 switch(position)//depending on the position will display the correct placement
	 {
		 case 1:
			 UARTStringPut("  ^              ", 17);
			 break;
		 case 2:
			 UARTStringPut("    ^            ", 17);
			 break;
		 case 3:
			 UARTStringPut("      ^          ", 17);
			 break;
		 case 4:
			 UARTStringPut("        ^        ", 17);
			 break;
		 case 5:
			 UARTStringPut("          ^      ", 17);
			 break;
		 case 6:
			 UARTStringPut("            ^    ", 17);
			 break;
		 case 7:
			 UARTStringPut("              ^  ", 17);
			 break;
	 }
	 SysCtlDelay(2000000);//delay so cursor does not zoom across
}
/*
 * moves lower on the terminal (like clicking enter on a word doc)
 */
void clearTerminal(void)
{
	UARTStringPut("\v\v\v\r", 4);
}

bool checkGamerOver(char board[SIZE_L][SIZE_W], int i_pos, int j_pos, bool player1)
{
	int count = 0;
	char check = player1 ? 'R' : 'Y';//figures whose turn was it
	for(int j = 0; j < SIZE_W; j++)
	{
		//checks for consective characters horizontally
		if(board[i_pos][j] == check)
		{
			count++;
			if(count >= 4)//if there are 4 of the same then it returns true
					return true;
		}
		else
			count = 0;//resets to 0 if not the same
	}
	count = 0;
	for(int i = 0; i < SIZE_L; i++)
	{
		//checks for consective characters vertically
		if(board[i][j_pos] == check)
		{
			count++;
			if(count >= 4)
					return true;
		}
		else
			count = 0;
	}
	count = 0;
	
	for(int i = 0; i < SIZE_L - 4; i++)
	{
    count = 0;
    for(int row = i, col = 0; row < SIZE_L && col < SIZE_W; row++, col++ )
		{
        if(board[row][col] == check)
				{
            count++;
            if(count >= 4) 
							return true;
        }
        else 
				{
            count = 0;
        }
    }
	}
	count = 0;
	// top-left to bottom-right 
	for(int j = 1; j < SIZE_W - 4; j++)
	{
			count = 0;
			for(int row = 0, col = j; row < SIZE_L && col < SIZE_W; row++, col++ )
		  {
					if(board[row][col] == check)
					{
							count++;
							if(count >= 4) 
								return true;
					}
					else 
					{
							count = 0;
					}
			}
	}
	
	count = 0;
	for(int i = 0; i < SIZE_L - 4; i++)
	{
    count = 0;
    for(int row = i, col = SIZE_W-1; row < SIZE_L && col >= 0; row++, col-- )
		{
        if(board[row][col] == check)
				{
            count++;
            if(count >= 4) 
							return true;
        }
        else 
				{
            count = 0;
        }
    }
	}
	count = 0;
	
	for(int j = SIZE_W - 2; j >= 3; j--)
	{
			count = 0;
			for(int row = 0, col = j; row < SIZE_L && col >= 0; row++, col-- )
		  {
					if(board[row][col] == check)
					{
							count++;
							if(count >= 4) 
								return true;
					}
					else 
					{
							count = 0;
					}
			}
	}
	return false;//if 4 in a row is not found
}


int main(void){
	
	PortFunctionInit();
	ADC_init();// initiallize ADC for analog signal of joystick
	UART_int_init();
	bool rightPressed = false;
	bool leftPressed = false;
	bool upPressed = false;
	bool downPressed = false;
	bool player1Turn = true;
	bool gameover = false;
	int position = 1;
	char board[SIZE_L][SIZE_W];
	
	for(int i = 0; i < SIZE_L; i++)
	{
		for(int j = 0 ; j < SIZE_W; j++)
		{
			board[i][j] = ' ';
		}
	}
	UARTStringPut("Red Players Turn\n\r", 18);
	Gen_Board(board); //generates board
	GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0x02); // red LED ON
	while(1)
	{
		/*
		 * Recieves 2 analog signals, CH0 and CH1, from the joystick using the ADC.
		 * Send one signal to ADC0 and the other to ADC1
		 * stores smaple to variable
		 */
		uint32_t AdcValues[1];
		uint32_t AdcValuest[1];
		ADCIntClear(ADC0_BASE,3);
		ADCIntClear(ADC1_BASE,3);
		ADCProcessorTrigger(ADC0_BASE,3);
		ADCProcessorTrigger(ADC1_BASE,3);
		while(!ADCIntStatus(ADC0_BASE,3,false));
		ADCSequenceDataGet(ADC0_BASE,3,AdcValues);
		while(!ADCIntStatus(ADC1_BASE,3,false));
		ADCSequenceDataGet(ADC1_BASE,3,AdcValuest);
		
		
		//joystick to the left
		if(AdcValues[0]<1000)
		{
				rightPressed = false;
				leftPressed = true;
				if(position > 1)
					position--;
				moveCusor(position);
	
		}
		//joystick to the right
		else if(AdcValues[0]>2700 )
		{
				leftPressed = false;
				rightPressed = true;
				if(position < SIZE_W)
					position++;
				moveCusor(position);
		}
		////joystick to the center
		else
		{
			 rightPressed = false;
			 leftPressed = false;
		}
		
		//checks whether the joystick is up and down, but is not really used in this project so it can be ignored
		if(AdcValuest[0]<1000)
		{
				upPressed = true;
		}
		else if(AdcValuest[0]>2700 )
		{
				
				
				downPressed = true;
		}
		else
		{
			 upPressed = false;
			 downPressed = false;
		}
		
		//checks if the botton connected to the joy stick is pressed
		//Used to decide where the player wants to place their piece
		if(GPIOPinRead(GPIO_PORTB_BASE,GPIO_PIN_5)== 0x0)//is pressed
		{
				
				for(int i = SIZE_L-1; i >= 0; i--)
				{
					if(board[i][position-1] == ' ')//will start on bottom row and checks if that row is occupied will tranverse to the next row if so until finds empty spot
					{
						if(player1Turn)
							board[i][position-1] = 'R';//places a R on the board
						else
							board[i][position-1] = 'Y';//places a Y on the board
						gameover = checkGamerOver(board, i, position-1, player1Turn);//checks if a player has won
						break;
					}
				}
				if(gameover)//if gameover stops games and tells player
				{
					clearTerminal();
					Gen_Board(board);
					clearTerminal();
					UARTStringPut("gameover\n\r", 10);
					if(player1Turn)
						UARTStringPut("Player 1 Wins\n\r", 15);
					else
						UARTStringPut("Player 2 Wins\n\r", 15);
					while(1)//infinite loop
					{
					}
				}
				else
				{
					player1Turn = player1Turn ? false : true;//switch players
				}
					//switch led according to who's turn
				if(player1Turn)
				{
				 GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, 0); // Green LED OFF
					clearTerminal();
					UARTStringPut("\n\rRed Player Turn\n\r", 19);
				}
				else
				{
					GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, 0x08); // Green LED ON
					clearTerminal();
					UARTStringPut("\n\rYellow Player Turn\n\r", 22);
				}
				clearTerminal();
				Gen_Board(board);//generates new board
				
				//SysCtlDelay(2000000);
		}
		else
		{
			
		}
		
	}
}
